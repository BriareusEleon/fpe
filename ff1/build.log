# github.com/capitalone/fpe/ff1
./ff1.go:70: cannot inline NewCipher: non-leaf function
./ff1.go:77: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:83: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:88: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:98: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:104: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:565: cannot inline Cipher.ciph: non-leaf op CALLINTER
./ff1.go:569: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:582: cannot inline Cipher.prf: non-leaf method
./ff1.go:120: cannot inline Cipher.Encrypt: non-leaf method
./ff1.go:130: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:173: inlining call to binary.binary.bigEndian.PutUint16 method(binary.bigEndian) func([]byte, uint16) { _ = binary.b·1[int(1)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(1)] = byte(binary.v·2) }
./ff1.go:178: inlining call to binary.binary.bigEndian.PutUint32 method(binary.bigEndian) func([]byte, uint32) { _ = binary.b·1[int(3)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(3)] = byte(binary.v·2) }
./ff1.go:179: inlining call to binary.binary.bigEndian.PutUint32 method(binary.bigEndian) func([]byte, uint32) { _ = binary.b·1[int(3)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(3)] = byte(binary.v·2) }
./ff1.go:295: inlining call to binary.binary.bigEndian.PutUint64 method(binary.bigEndian) func([]byte, uint64) { _ = binary.b·1[int(7)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(56)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(48)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(40)); binary.b·1[int(3)] = byte(binary.v·2 >> uint(32)); binary.b·1[int(4)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(5)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(6)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(7)] = byte(binary.v·2) }
./ff1.go:342: cannot inline Cipher.Decrypt: non-leaf method
./ff1.go:352: inlining call to errors.New func(string) error { return error(&errors.errorString literal) }
./ff1.go:395: inlining call to binary.binary.bigEndian.PutUint16 method(binary.bigEndian) func([]byte, uint16) { _ = binary.b·1[int(1)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(1)] = byte(binary.v·2) }
./ff1.go:400: inlining call to binary.binary.bigEndian.PutUint32 method(binary.bigEndian) func([]byte, uint32) { _ = binary.b·1[int(3)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(3)] = byte(binary.v·2) }
./ff1.go:401: inlining call to binary.binary.bigEndian.PutUint32 method(binary.bigEndian) func([]byte, uint32) { _ = binary.b·1[int(3)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(3)] = byte(binary.v·2) }
./ff1.go:517: inlining call to binary.binary.bigEndian.PutUint64 method(binary.bigEndian) func([]byte, uint64) { _ = binary.b·1[int(7)]; binary.b·1[int(0)] = byte(binary.v·2 >> uint(56)); binary.b·1[int(1)] = byte(binary.v·2 >> uint(48)); binary.b·1[int(2)] = byte(binary.v·2 >> uint(40)); binary.b·1[int(3)] = byte(binary.v·2 >> uint(32)); binary.b·1[int(4)] = byte(binary.v·2 >> uint(24)); binary.b·1[int(5)] = byte(binary.v·2 >> uint(16)); binary.b·1[int(6)] = byte(binary.v·2 >> uint(8)); binary.b·1[int(7)] = byte(binary.v·2) }
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:77
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:83
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:88
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:98
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:104
./ff1.go:70: leaking param: tweak to result ~r4 level=0
./ff1.go:70: 	from newCipher (dot-equals) at ./ff1.go:109
./ff1.go:70: 	from ~r4 (return) at ./ff1.go:115
./ff1.go:77: error(&errors.errorString literal) escapes to heap
./ff1.go:77: 	from ~r0 (assign-pair) at ./ff1.go:77
./ff1.go:77: 	from ~r5 (return) at ./ff1.go:77
./ff1.go:77: &errors.errorString literal escapes to heap
./ff1.go:77: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:77
./ff1.go:77: 	from ~r0 (assign-pair) at ./ff1.go:77
./ff1.go:77: 	from ~r5 (return) at ./ff1.go:77
./ff1.go:83: error(&errors.errorString literal) escapes to heap
./ff1.go:83: 	from ~r0 (assign-pair) at ./ff1.go:83
./ff1.go:83: 	from ~r5 (return) at ./ff1.go:83
./ff1.go:83: &errors.errorString literal escapes to heap
./ff1.go:83: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:83
./ff1.go:83: 	from ~r0 (assign-pair) at ./ff1.go:83
./ff1.go:83: 	from ~r5 (return) at ./ff1.go:83
./ff1.go:88: error(&errors.errorString literal) escapes to heap
./ff1.go:88: 	from ~r0 (assign-pair) at ./ff1.go:88
./ff1.go:88: 	from ~r5 (return) at ./ff1.go:88
./ff1.go:88: &errors.errorString literal escapes to heap
./ff1.go:88: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:88
./ff1.go:88: 	from ~r0 (assign-pair) at ./ff1.go:88
./ff1.go:88: 	from ~r5 (return) at ./ff1.go:88
./ff1.go:98: error(&errors.errorString literal) escapes to heap
./ff1.go:98: 	from ~r0 (assign-pair) at ./ff1.go:98
./ff1.go:98: 	from ~r5 (return) at ./ff1.go:98
./ff1.go:98: &errors.errorString literal escapes to heap
./ff1.go:98: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:98
./ff1.go:98: 	from ~r0 (assign-pair) at ./ff1.go:98
./ff1.go:98: 	from ~r5 (return) at ./ff1.go:98
./ff1.go:104: error(&errors.errorString literal) escapes to heap
./ff1.go:104: 	from ~r0 (assign-pair) at ./ff1.go:104
./ff1.go:104: 	from ~r5 (return) at ./ff1.go:104
./ff1.go:104: &errors.errorString literal escapes to heap
./ff1.go:104: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:104
./ff1.go:104: 	from ~r0 (assign-pair) at ./ff1.go:104
./ff1.go:104: 	from ~r5 (return) at ./ff1.go:104
./ff1.go:70: leaking param: key
./ff1.go:70: 	from key (passed to call[argument escapes]) at ./ff1.go:102
./ff1.go:569: error(&errors.errorString literal) escapes to heap
./ff1.go:569: 	from ~r0 (assign-pair) at ./ff1.go:569
./ff1.go:569: 	from ~r2 (return) at ./ff1.go:569
./ff1.go:569: &errors.errorString literal escapes to heap
./ff1.go:569: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:569
./ff1.go:569: 	from ~r0 (assign-pair) at ./ff1.go:569
./ff1.go:569: 	from ~r2 (return) at ./ff1.go:569
./ff1.go:565: leaking param: input
./ff1.go:565: 	from c.cbcEncryptor.CryptBlocks(input, input) (parameter to indirect call) at ./ff1.go:572
./ff1.go:565: leaking param: c
./ff1.go:565: 	from c.cbcEncryptor.CryptBlocks(input, input) (receiver in indirect call) at ./ff1.go:572
./ff1.go:582: leaking param: c
./ff1.go:582: 	from c (passed to call[argument escapes]) at ./ff1.go:583
./ff1.go:582: leaking param: input
./ff1.go:582: 	from input (passed to call[argument escapes]) at ./ff1.go:583
./ff1.go:335: A + B escapes to heap
./ff1.go:335: 	from ret (assigned) at ./ff1.go:335
./ff1.go:335: 	from ~r1 (return) at ./ff1.go:130
./ff1.go:130: error(&errors.errorString literal) escapes to heap
./ff1.go:130: 	from ~r0 (assign-pair) at ./ff1.go:130
./ff1.go:130: 	from ~r2 (return) at ./ff1.go:130
./ff1.go:130: &errors.errorString literal escapes to heap
./ff1.go:130: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:130
./ff1.go:130: 	from ~r0 (assign-pair) at ./ff1.go:130
./ff1.go:130: 	from ~r2 (return) at ./ff1.go:130
./ff1.go:120: leaking param: X
./ff1.go:120: 	from X (passed to call[argument escapes]) at ./ff1.go:137
./ff1.go:199: make([]byte, totalBufLen) escapes to heap
./ff1.go:199: 	from make([]byte, totalBufLen) (too large for stack) at ./ff1.go:199
./ff1.go:120: leaking param content: c
./ff1.go:120: 	from c.tweak (dot) at ./ff1.go:208
./ff1.go:120: 	from *c.tweak (indirection) at ./ff1.go:208
./ff1.go:120: 	from copy(Q[:t], c.tweak) (copied slice) at ./ff1.go:208
./ff1.go:332: "0" + B escapes to heap
./ff1.go:332: 	from B (assigned) at ./ff1.go:332
./ff1.go:332: 	from B (passed to call[argument escapes]) at ./ff1.go:253
./ff1.go:120: leaking param: c
./ff1.go:120: 	from c (passed to call[argument escapes]) at ./ff1.go:280
./ff1.go:137: Cipher.Encrypt numX does not escape
./ff1.go:165: Cipher.Encrypt make([]byte, aes.BlockSize) does not escape
./ff1.go:226: Cipher.Encrypt numRadix does not escape
./ff1.go:241: Cipher.Encrypt numU does not escape
./ff1.go:242: Cipher.Encrypt numV does not escape
./ff1.go:244: Cipher.Encrypt numModU does not escape
./ff1.go:244: Cipher.Encrypt &numRadix does not escape
./ff1.go:244: Cipher.Encrypt &numU does not escape
./ff1.go:245: Cipher.Encrypt numModV does not escape
./ff1.go:245: Cipher.Encrypt &numRadix does not escape
./ff1.go:245: Cipher.Encrypt &numV does not escape
./ff1.go:248: Cipher.Encrypt numA does not escape
./ff1.go:253: Cipher.Encrypt numB does not escape
./ff1.go:263: Cipher.Encrypt numB does not escape
./ff1.go:310: Cipher.Encrypt numY does not escape
./ff1.go:312: Cipher.Encrypt numC does not escape
./ff1.go:312: Cipher.Encrypt &numA does not escape
./ff1.go:312: Cipher.Encrypt &numY does not escape
./ff1.go:315: Cipher.Encrypt numC does not escape
./ff1.go:315: Cipher.Encrypt &numC does not escape
./ff1.go:315: Cipher.Encrypt &numModU does not escape
./ff1.go:317: Cipher.Encrypt numC does not escape
./ff1.go:317: Cipher.Encrypt &numC does not escape
./ff1.go:317: Cipher.Encrypt &numModV does not escape
./ff1.go:322: Cipher.Encrypt numA does not escape
./ff1.go:326: Cipher.Encrypt numA does not escape
./ff1.go:327: Cipher.Encrypt numB does not escape
./ff1.go:557: A + B escapes to heap
./ff1.go:557: 	from ret (assigned) at ./ff1.go:557
./ff1.go:557: 	from ~r1 (return) at ./ff1.go:352
./ff1.go:352: error(&errors.errorString literal) escapes to heap
./ff1.go:352: 	from ~r0 (assign-pair) at ./ff1.go:352
./ff1.go:352: 	from ~r2 (return) at ./ff1.go:352
./ff1.go:352: &errors.errorString literal escapes to heap
./ff1.go:352: 	from error(&errors.errorString literal) (interface-converted) at ./ff1.go:352
./ff1.go:352: 	from ~r0 (assign-pair) at ./ff1.go:352
./ff1.go:352: 	from ~r2 (return) at ./ff1.go:352
./ff1.go:342: leaking param: X
./ff1.go:342: 	from X (passed to call[argument escapes]) at ./ff1.go:359
./ff1.go:421: make([]byte, totalBufLen) escapes to heap
./ff1.go:421: 	from make([]byte, totalBufLen) (too large for stack) at ./ff1.go:421
./ff1.go:342: leaking param content: c
./ff1.go:342: 	from c.tweak (dot) at ./ff1.go:430
./ff1.go:342: 	from *c.tweak (indirection) at ./ff1.go:430
./ff1.go:342: 	from copy(Q[:t], c.tweak) (copied slice) at ./ff1.go:430
./ff1.go:554: "0" + A escapes to heap
./ff1.go:554: 	from A (assigned) at ./ff1.go:554
./ff1.go:554: 	from A (passed to call[argument escapes]) at ./ff1.go:470
./ff1.go:342: leaking param: c
./ff1.go:342: 	from c (passed to call[argument escapes]) at ./ff1.go:502
./ff1.go:359: Cipher.Decrypt numX does not escape
./ff1.go:387: Cipher.Decrypt make([]byte, aes.BlockSize) does not escape
./ff1.go:448: Cipher.Decrypt numRadix does not escape
./ff1.go:463: Cipher.Decrypt numU does not escape
./ff1.go:464: Cipher.Decrypt numV does not escape
./ff1.go:466: Cipher.Decrypt numModU does not escape
./ff1.go:466: Cipher.Decrypt &numRadix does not escape
./ff1.go:466: Cipher.Decrypt &numU does not escape
./ff1.go:467: Cipher.Decrypt numModV does not escape
./ff1.go:467: Cipher.Decrypt &numRadix does not escape
./ff1.go:467: Cipher.Decrypt &numV does not escape
./ff1.go:470: Cipher.Decrypt numA does not escape
./ff1.go:475: Cipher.Decrypt numB does not escape
./ff1.go:485: Cipher.Decrypt numA does not escape
./ff1.go:532: Cipher.Decrypt numY does not escape
./ff1.go:534: Cipher.Decrypt numC does not escape
./ff1.go:534: Cipher.Decrypt &numB does not escape
./ff1.go:534: Cipher.Decrypt &numY does not escape
./ff1.go:537: Cipher.Decrypt numC does not escape
./ff1.go:537: Cipher.Decrypt &numC does not escape
./ff1.go:537: Cipher.Decrypt &numModU does not escape
./ff1.go:539: Cipher.Decrypt numC does not escape
./ff1.go:539: Cipher.Decrypt &numC does not escape
./ff1.go:539: Cipher.Decrypt &numModV does not escape
./ff1.go:544: Cipher.Decrypt numB does not escape
./ff1.go:548: Cipher.Decrypt numA does not escape
./ff1.go:549: Cipher.Decrypt numB does not escape
<autogenerated>:1: leaking param content: .this
<autogenerated>:1: 	from .this (indirection) at <autogenerated>:1
<autogenerated>:1: 	from .this (passed to call[argument escapes]) at <autogenerated>:1
<autogenerated>:1: leaking param: X
<autogenerated>:1: 	from X (passed to call[argument escapes]) at <autogenerated>:1
<autogenerated>:2: leaking param content: .this
<autogenerated>:2: 	from .this (indirection) at <autogenerated>:2
<autogenerated>:2: 	from .this (passed to call[argument escapes]) at <autogenerated>:2
<autogenerated>:2: leaking param: X
<autogenerated>:2: 	from X (passed to call[argument escapes]) at <autogenerated>:2
<autogenerated>:3: leaking param content: .this
<autogenerated>:3: 	from .this (indirection) at <autogenerated>:3
<autogenerated>:3: 	from .this (passed to call[argument escapes]) at <autogenerated>:3
<autogenerated>:3: leaking param: input
<autogenerated>:3: 	from input (passed to call[argument escapes]) at <autogenerated>:3
<autogenerated>:4: leaking param content: .this
<autogenerated>:4: 	from .this (indirection) at <autogenerated>:4
<autogenerated>:4: 	from .this (passed to call[argument escapes]) at <autogenerated>:4
<autogenerated>:4: leaking param: input
<autogenerated>:4: 	from input (passed to call[argument escapes]) at <autogenerated>:4
<autogenerated>:5: leaking param: .this
<autogenerated>:5: 	from .this.BlockSize() (receiver in indirect call) at <autogenerated>:5
<autogenerated>:6: leaking param: cipher.dst
<autogenerated>:6: 	from .this.CryptBlocks(cipher.dst, cipher.src) (parameter to indirect call) at <autogenerated>:6
<autogenerated>:6: leaking param: cipher.src
<autogenerated>:6: 	from .this.CryptBlocks(cipher.dst, cipher.src) (parameter to indirect call) at <autogenerated>:6
<autogenerated>:6: leaking param: .this
<autogenerated>:6: 	from .this.CryptBlocks(cipher.dst, cipher.src) (receiver in indirect call) at <autogenerated>:6
<autogenerated>:7: leaking param: .anon0
<autogenerated>:7: 	from .this.SetIV(.anon0) (parameter to indirect call) at <autogenerated>:7
<autogenerated>:7: leaking param: .this
<autogenerated>:7: 	from .this.SetIV(.anon0) (receiver in indirect call) at <autogenerated>:7
<autogenerated>:8: leaking param: .this
<autogenerated>:8: 	from .this.Error() (receiver in indirect call) at <autogenerated>:8
